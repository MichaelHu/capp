<p>% object c keywords</p><p>BOOLNSUInteger</p><p>Class: 表示ObjC类信息的结构体</p><p>idvoidNSString</p><p>@class</p><p>@protocol @end</p><p>@optional:</p><p>@interface SimpleClass : NSObject</p>
<pre><code>...</code></pre>
<p>@end类声明，描述了类的行为，通常处于.h后缀的文件中，通过interface，可以了解该类能对外提供哪些功能。SimpleClass继承了NSObject类</p><p>@interface BirdsAppDelegate : UIResponder <UIApplicationDelegate>BirdsAppDelegate类继承自UIResponder类，实现UIApplicationDelegate接口。</p><pre><code>...</code></pre>
<p>...@end</p><p>@package什么作用？</p><p><UIApplicationDelegate>: UIApplicationDelegate是一个接口，而不是一个类它声明了单例UIApplication对象的代理需实现的方法，提供了app执行过程中的关键事件信息，比如启动完毕、内存低、重要改变发生等。</p><p>UIApplicationDelegate接口声明了哪些方法？applicationDidFinishLaunching, application:willFinishLaunchingwithOptions, application:didFinishLaunchingwithOptions, applicationDidBecomeActive, applicationWillTerminate, applicationSignificantTimeChange, application:willChangeStatusBarOrientation, application:didChangeStatusBarOrientation, application:willChangeStatusBarFrame, application:didChangeStatusBarFrame, application:didRegisterForRemoteNotificationsWithDeviceToken, application:didFailToRegisterForNotificationsWithError, application:didReceiveRemoteNotification, application:didReceiveLocalNotification, application:didReceiveRemoteNotification:fetchCompletionHandler, application:performFetchWithCompletionHandler, application:handleEventsBackgroundURLSession:completionHandler, applicationDidEnterBackground, applicationWillEnterBackground等等</p><p>类似函数指针，用于表示代码块（Block）</p><p>定义一个块类型：</p>
<pre><code>...</code></pre>
<p>@property属性声明，包含在@iterface中，格式如：</p><p>属性声明中指定属性的只读特征，不允许被外界修改，比如：</p><p>实例方法声明，方法指示对象可以接收的信息</p><p>类方法声明？</p><p>与C函数声明的区别：返回类型用括号包围；"-"标识类的实例方法；C函数参数用括号包围，ObjC参数用":"分隔</p><p>多参数方法声明：方法名为： someMethodWithFirstValue:secondValue，也即所谓的参数inline于方法名中。</p><p>@implementation@end类实现，描述了类的内部行为，处于.m后缀的文件中</p>
<h1># import "XYZPerson.h"</h1>
<p>@implementation XYZPerson</p>
<pre><code>NSLog(@"Hello, World!");</code></pre>
<p>@end</p><p>日志输出函数，c函数调用方式，target output能够查看到输出</p><p>NSObject大部分ObjC类的基类</p><p>@protocol UIApplicationDelegate<NSObject>NSObject能做一个protocol用？还是说定义protocol时，一个类可作为其需实现的接口？</p><p>NSDate表示一个类簇，其本身是一个抽象基类</p><h1># import</h1><p>main.m文件在Supporting Files目录下，入口文件，包含main函数，如：</p>
<pre><code>...</code></pre>
<p>main与UIApplicationMain前者是C的main，后者是Application Main</p><p>UIApplicationMain的声明：   int argc,该函数处于C的main入口函数中，用于创建application对象，application delegate对象，并且建立事件循环。</p><p>IBAction:</p><p>在main函数中，该结构内部可以包含return语句，如：</p>
<pre><code>return UIApplicationMain(<pre><code>argc, argv, nil, NSStringFromClass([BirdsAppDelegate class])</code></pre>
)</code></pre>
<p>直接使用AutoreleasePool:</p><p>release消息：使reference count减1，如果减至0，接收者还会接收到dealloc消息</p><p>@synthesize 属性名;@implementation GLGravityAppDelegate@synthesize window;</p><p>@dynamic 属性名;@dynamic animationFrameInterval;</p><p>nil类似NULL</p><p>调用BirdsAppDelegate类的class方法，并返回数据</p><p>immuatbleObjC中，NSString和NSNumber都是immutable类型，内部内容只在创建时设置，后续不能再改动。如果要用新的值，只能通过再创建一个新实例。</p><p>NSMutableString与NSString类提供一样的接口，不同的是其为可变字符串类，其内容可以动态改变。NSMutableString继承自NSString</p><p>NSObject, UIResponder, UIView, UIControl, UIButton左至右逐级继承</p><p>UIResponder抽象出对象能对用户输入做出响应的特征</p><p>UIView抽象出对象能在屏幕上显示的特征</p><p>UIControl抽象出所有用户控件的通用行为特征</p><p>NSObject抽象了所有ObjC对象的基本特征，对象之间可以进行通信</p><p>UIWindow类定义了window对象，管理和协调一个app的所有view</p><p>app和UIWindow：一个app只能有一个window，除非app还有外部设备用于展示内容</p><p>UIResponder有哪些方法？nextResponder, touchesBegan:withEvent, motionBegan:withEvent等</p><p>UIWindow有哪些方法？还有convertPoint:toWindow, convertPoint:fromWindow, convertRect:toWindow, convertRect:fromWindow等进行点、矩形转换的方法另还有KeyWindow相关的方法。</p><p>UIWindow有哪些属性？screen, windowLevel, keyWindow, rootViewController</p><p>UITableViewController类继承自UIViewController类，实现UITableViewDelegate和UITableViewDataSource协议除了继承和实现的方法，其还包含initWithStyle方法，另外还包含属性：tableView, clearsSelectionOnViewWillAppear, refreshControl</p><p>UITableView类</p><p>UIViewController类：提供ios APP的基础视图管理模型。一般很少直接实例化该类。继承自UIResponder，并实现NSCoding和UIAppearanceContainer协议。</p><p>UIViewController类有哪些属性？view, nibName, nibBundle, storyboard, title, parentViewController, modalViewController, presentedViewController, presentingViewController, definesPresentationContext, providesPresentationContextTransitionStyle, modalTransitionStyle, modalPresentationStyle, modalPresentationCapturesStatusBarAppearance, wantsFullScreenLayout, edgesForExtendedLayout, extendedLayoutIncludesOpaqueBars, automaticallyAdjustsScrollViewInsets, preferredContentSize等 </p><p>UIViewController有哪些方法？initWithNibName:bundle, loadView, viewWillUnload, viewDidUnload, viewDidLoad, isViewLoaded, performSegueWithIdentifier:sender,shouldPerformSegueWithIdentifier:sender, prepareForSegue:sender, canPerformUnwindSegueAction:fromViewController:withSender,viewControllerForUnwindSegueAction:fromViewController:withSender, segueForUnwindingToViewController:fromViewController:identifier,viewWillAppear, viewDidAppear, viewWillDisappear, viewDidDisappear等</p><p>除了用.nib文件来定义view controller之外，也可以用storyboard来定义，如果用storyboard，将不再用代码直接创建view controller，而是交由storyboard来创建</p><p>.plist文件定义属性列表？GLPaint-info.plist定义Main nib file base name, Status bar is initially hidden, Bundle display name, Icon file, Bundle identifier, Bundle name等等</p><p>.pch文件：</p><p>以下这句什么含义？以上在.h文件中</p><p>参考：// A class extension to declare private methods@end类扩展，声明私有实例方法，存在于.m文件中</p><p>类扩展，声明私有实例变量，存在于.m文件中，有Block包围</p>
<pre><code>GLint backingWidth;...</code></pre>
<p>@end</p><p>UIStoryboardSegue：处理两个视图控制器间的视觉切换。segue对象包含在转换中涉及的视图控制器的信息。包含三个方法：三个属性：identifier, sourceViewController, destinationViewController</p><p>UIApplication是一个类，控制和协调ios app的中心点。每个app有且仅有一个UIApplication（或它的子类）的实例。app启动时，UIApplicationMain函数被调用。该函数会创建单例UIApplication对象，其后该实例对象可以通过类方法sharedApplication获取</p><p>看懂StoryBoard：定义UI组件、视图切换（segue）、关系（relationship）等</p><p>root view controller</p><p>CAAnimation类CAMediaTiming protocol</p><p>UIAccelerometer，重力感应</p><p>NSDictionary类...可变参数列表，用逗号分隔。以下是一个例子：</p>
<pre><code>@"value1", @"key1", @"value2", @"key2", nil];</code></pre>
<p>可视化2D或3D数据，将函数调用转换成显卡命令，直接用于底层图形硬件。</p><p>IBOutlet: </p><p>对象方法调用使用消息发送语法，当然C函数调用方式是不变的。所以分清是NSObject方法调用还是C函数调用两种场景。</p><p>UISegmentedControl</p>
<pre><code>rect.origin.x + kLeftMargin, rect.size.height - kPaletteHeight - kTopMargin, rect.size.width - (kLeftMargin + kRightMargin), kPaletteHeight</code></pre>
<p>segmentedControl.frame = frame;</p>
<pre><code>addTarget:self action:@selector(changeBrushColor:) forControlEvents:UIControlEventValueChanged</code></pre>
<p>NSNotificationCenter: 事件中心，通知派发中心</p>
<pre><code>addObserver:self selector:@selector(eraseView) name:@"shake" object:nil</code></pre>
<p>实例方法引用，带引号表明有参数，不带引号没参数</p><p>UITouch: </p><p>EAGLContext：OpenGL ES渲染上下文，执行OpenGL ES渲染指令前，需要有一个EAGLContext将指定context设置为当前调用线程的redering context</p><p>CAEAGLLayer: 支持将OpenGL内容绘制在iPhone APP中</p><p>fileUtil.h</p><p>让UIView能进行OpenGL ES的渲染，重写UIView的类方法layerClass：</p>
<pre><code>return [CAEAGLLayer class];</code></pre>
<p>NSBundle: 管理应用程序可以使用的代码和资源，代表文件系统中的位置</p>
